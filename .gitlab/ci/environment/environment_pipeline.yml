---
# This pipeline uses Terraform to manage machine state, and GitLab to manage that state.
# Documentation: https://docs.gitlab.com/ee/user/infrastructure/iac/terraform_state.html
stages:
  - infrastructure
  - provision

# Define pipeline-global variables.
variables:
  TF_LOCAL_ROOT: "${CI_PROJECT_DIR}/terraform"
  TF_ADDRESS: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/${TARGET_ENVIRONMENT}"

# Template job for setting up the environment
.environment_setup_template:
  image: artifacts.knut.univention.de/upx/container-tooling/automation-terraform:main-857e10e8
  stage: infrastructure
  before_script:
    - cd ${TF_LOCAL_ROOT}
    - >
      terraform
      init
      -backend-config="address=${TF_ADDRESS}"
      -backend-config="lock_address=${TF_ADDRESS}/lock"
      -backend-config="unlock_address=${TF_ADDRESS}/lock"
      -backend-config="username=gitlab-ci-token"
      -backend-config="password=${CI_JOB_TOKEN}"
      -backend-config="lock_method=POST"
      -backend-config="unlock_method=DELETE"
      -backend-config="retry_wait_min=5"
      -backend-config="skip_cert_verification=true"

# This job stops the environment and deletes the Terraform state from the GitLab storage backend.
# Maintainer permissions are needed for this task to complete successfully.
teardown_environment:
  extends: .environment_setup_template
  environment:
    name: $TARGET_ENVIRONMENT
    action: stop
  when: manual
  script:
    - terraform refresh
    - terraform destroy -auto-approve
    - >
      curl
      --insecure
      --header "Private-Token: ${CI_JOB_TOKEN}"
      --request DELETE "${TF_ADDRESS}"

# Setup of the VM for the target environment
setup_environment:
  extends: .environment_setup_template
  rules:
    - when: always
  script:
    - terraform version
    - terraform refresh
    - terraform destroy -auto-approve
    - >
      terraform
      apply
      -auto-approve
      -var target_environment=${TARGET_ENVIRONMENT}
      -var project_name_slug=${CI_PROJECT_NAME}
      -var create_dns_record=true
  after_script:
    - cd ${TF_LOCAL_ROOT}
    - SERVER_IP=$(terraform output server_ip | sed -e 's/^"//' -e 's/"$//')
    - SERVER_SUBDOMAIN=$(terraform output server_subdomain | sed -e 's/^"//' -e 's/"$//')
    - SERVER_HTTPS_URL_PRIMARY=$(terraform output server_https_url_primary | sed -e 's/^"//' -e 's/"$//')
    - echo "SERVER_IP=${SERVER_IP}" >> ${CI_PROJECT_DIR}/deploy.env
    - echo "SERVER_SUBDOMAIN=${SERVER_SUBDOMAIN}" >> ${CI_PROJECT_DIR}/deploy.env
    - echo "SERVER_HTTPS_URL_PRIMARY=${SERVER_HTTPS_URL_PRIMARY}" >> ${CI_PROJECT_DIR}/deploy.env
  artifacts:
    reports:
      dotenv: "${CI_PROJECT_DIR}/deploy.env"
  environment:
    name: $TARGET_ENVIRONMENT
    url: "https://${SERVER_HTTPS_URL_PRIMARY}"
    on_stop: teardown_environment
  resource_group: $TARGET_ENVIRONMENT

# Provisionig of the VM for the target environment
# This runs The Univention `ucs_join` Ansible role to set a hostname.
# See: https://github.com/univention/ansible-roles#rolesucs_joinreadmemd
provision_environment:
  image: "artifacts.knut.univention.de/upx/container-tooling/automation-ansible:main"
  stage: provision
  rules:
    - when: always
  variables:
    ANSIBLE_ROOT: "${CI_PROJECT_DIR}/ansible"
  needs:
    - "setup_environment"
  before_script:
    # Run ssh-agent (inside the build environment)
    - eval $(ssh-agent -s)

    # Pipe SSH key into SSH Agent without carriage returns.
    # See: https://gitlab.com/gitlab-examples/ssh-private-key/issues/1#note_48526556
    - echo "${ID_RSA_UCS_KVM_IMAGE}" | tr -d '\r' | ssh-add -

    # Install Ansible dependencies
    - ansible-galaxy install -r ${ANSIBLE_ROOT}/requirements.yml
  script:
    - ansible --version
    - >
      ansible-playbook
      --inventory ${SERVER_IP},
      --become-user root
      --ssh-common-args "-o StrictHostKeyChecking=no"
      ${ANSIBLE_ROOT}/provision_ucs_environment.yml
      --extra-vars "ansible_python_interpreter=auto"
      --extra-vars "basedn=dc=${SERVER_SUBDOMAIN}"
      --extra-vars "domain_name=${SERVER_HTTPS_URL_PRIMARY}"
      --extra-vars "host_name=${SERVER_SUBDOMAIN}"
      --extra-vars "server_ip=${SERVER_IP}/24"
      --extra-vars "admin_user_name=${UCS_JOIN_ADMIN_USER_NAME}"
      --extra-vars "root_password=${UCS_JOIN_ROOT_PASSWORD}"
  environment:
    name: $TARGET_ENVIRONMENT
    url: "https://${SERVER_HTTPS_URL_PRIMARY}"
    on_stop: teardown_environment
  resource_group: $TARGET_ENVIRONMENT
