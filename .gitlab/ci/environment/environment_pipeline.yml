---
# This pipeline uses Terraform to manage machine state, and GitLab to manage that state.
# Documentation: https://docs.gitlab.com/ee/user/infrastructure/iac/terraform_state.html
stages:
  - infrastructure
  - provision

# Define pipeline-global variables.
variables:
  TF_LOCAL_ROOT: "${CI_PROJECT_DIR}/terraform"
  TF_ADDRESS: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/${TARGET_ENVIRONMENT}"
  DNS_DOMAIN: "keycloak-extensions-${TARGET_ENVIRONMENT}"

# Template job for setting up the environment
.environment_setup_template:
  image: artifacts.knut.univention.de/upx/container-tooling/automation-terraform:main-857e10e8
  stage: infrastructure
  before_script:
    - cd ${TF_LOCAL_ROOT}
    - >
      terraform
      init
      -backend-config="address=${TF_ADDRESS}"
      -backend-config="lock_address=${TF_ADDRESS}/lock"
      -backend-config="unlock_address=${TF_ADDRESS}/lock"
      -backend-config="username=gitlab-ci-token"
      -backend-config="password=${CI_JOB_TOKEN}"
      -backend-config="lock_method=POST"
      -backend-config="unlock_method=DELETE"
      -backend-config="retry_wait_min=5"
      -backend-config="skip_cert_verification=true"

# Setup of the VM for the target environment
setup_environment:
  extends: .environment_setup_template
  rules:
    - when: always
  script:
    - terraform version
    - terraform refresh
    - terraform destroy -auto-approve
    - >
      terraform
      apply
      -auto-approve
      -var ci_target_environment=${TARGET_ENVIRONMENT}
      -var dns-domain=${DNS_DOMAIN}
      -var create-dns-record=true
  after_script:
    - cd ${TF_LOCAL_ROOT}
    - SERVER_IP=$(terraform output server_ip | sed -e 's/^"//' -e 's/"$//')
    - SERVER_HTTPS_URL_PRIMARY=$(terraform output server_https_url_primary | sed -e 's/^"//' -e 's/"$//')
    - echo "SERVER_IP=${SERVER_IP}" >> ${CI_PROJECT_DIR}/deploy.env
    - echo "SERVER_HTTPS_URL_PRIMARY=${SERVER_HTTPS_URL_PRIMARY}" >> ${CI_PROJECT_DIR}/deploy.env
  artifacts:
    reports:
      dotenv: "${CI_PROJECT_DIR}/deploy.env"
  environment:
    name: $TARGET_ENVIRONMENT
    on_stop: teardown_environment
    url: "https://${SERVER_HTTPS_URL_PRIMARY}"
  resource_group: $TARGET_ENVIRONMENT

# This job stops the environment and deletes the Terraform state from the GitLab storage backend.
# Maintainer permissions are needed for this task to complete successfully.
teardown_environment:
  extends: .environment_setup_template
  environment:
    name: $TARGET_ENVIRONMENT
    action: stop
  rules:
    - when: manual
  script:
    - terraform refresh
    - terraform destroy -auto-approve
    - >
      curl
      --insecure
      --header "Private-Token: ${CI_JOB_TOKEN}"
      --request DELETE "${TF_ADDRESS}"

# Provisioing of the VM for the target environment
# This runs UCS join, so that a hostname can be set.
# TODO: Find out where this is documented.
provision_ucs_vm:
  image: artifacts.knut.univention.de/upx/container-tooling/automation-ansible:main-0ff77d38
  stage: provision
  rules:
    - when: always
  before_script:
    - echo "${ID_RSA_UCS_KVM_IMAGE}" > ${CI_PROJECT_DIR}/id_rsa
    - chown 0400 ${CI_PROJECT_DIR}/id_rsa
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - chmod -R o-w .
    - chmod -R ug+rw .
    - cat "${AUTHORIZED_KEYS_FILE}" > ansible/files/authorized_keys
    - cd ansible
    - ansible-galaxy install -r collections/requirements.yml
  needs:
    - "setup_environment"
  environment:
    name: $TARGET_ENVIRONMENT
    on_stop: teardown_environment
    url: "https://${SERVER_HTTPS_URL_PRIMARY}"
  resource_group: $TARGET_ENVIRONMENT
  script:
    - >
      ansible-playbook
      -i root@${SERVER_IP}, playbook.yml
      -e "hostname=master"
      -e "domain_name=$SERVER_HTTPS_URL_PRIMARY"
      -e "basedn=dc=${DNS_DOMAIN},dc=at-univention,dc=de"